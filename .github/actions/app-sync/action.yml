name: app-sync
author: ghostsquad
description: upserts and syncs applications
inputs:
  argocd-server-url:
    description: The URL to use for the ArgoCD server (e.g. `http://localhost:8080`)
    required: true
  application-file:
    description: Path to application to upsert & sync
    required: true
  timeout:
    description: Time out after this many seconds
    required: false
    default: "30"
  port-forward-log:
    description: the path to the port-forward-log (debugging)
    default: "/dev/null"
  dex-curl-options:
    description: curl options when making the request to dex
    default: ""
  mise-install:
    description: whether or not to install mise and mise-managed tools (demo/debugging only)
    default: "false"

runs:
  using: "composite"
  steps:
  - uses: frenck/action-setup-yq@c4b5be8b4a215c536a41d436757d9feb92836d4f # v1.0.2
  - uses: jdx/mise-action@v3
    if: inputs.mise-install
    with:
      version: v2025.10.8
      install: true
      cache: true
  # Actions have access to two special environment variables ACTIONS_CACHE_URL and ACTIONS_RUNTIME_TOKEN.
  # Inline step scripts in workflows do not see these variables.
  - uses: actions/github-script@v6
    id: script
    with:
      debug: true
      script: |-
        const token = process.env['ACTIONS_RUNTIME_TOKEN']
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']
        core.setOutput('TOKEN', token.trim())
        core.setOutput('IDTOKENURL', runtimeUrl.trim())
  - name: Obtain access token
    id: idtoken
    shell: bash
    run: |-
      set -euo pipefail
      
      set +x

      debug() {
        local title="${1}"
        local content="${2}"

        echo "::group::DEBUG ${title}"
        echo "${content}"
        echo "::endgroup::"
      }

      # get an token from github
      echo "getting token from GitHub"
      if GH_TOKEN_RESPONSE=$(curl -sS --fail-with-body \
        '${{ steps.script.outputs.IDTOKENURL }}' \
        -H "Authorization: bearer  ${{ steps.script.outputs.TOKEN }}" \
        -H "Accept: application/json; api-version=2.0" \
        -H "Content-Type: application/json" \
        -d "{}" \
      ); then
        echo "GH_TOKEN request success"
      else
        echo "GH_TOKEN request failed!"
        debug "GH_TOKEN_RESPONSE (RAW)" "${GH_TOKEN_RESPONSE}"
        exit 1
      fi
      
      debug "GH_TOKEN_RESPONSE (RAW)" "${GH_TOKEN_RESPONSE}"
      
      GH_TOKEN=$(jq -r .value <<< $GH_TOKEN_RESPONSE)
      echo "::add-mask::$GH_TOKEN"
      
      # echo "::group::DEBUG /api/dex/.well-known/openid-configuration"
      # curl -v -sS --fail-with-body ${{ inputs.dex-curl-options }} \
      #        "${{ inputs.argocd-server-url }}/api/dex/.well-known/openid-configuration"
      #      echo "::endgroup::"

      # exchange it for a dex token
      DEX_URL="${{ inputs.argocd-server-url }}/api/dex/token"
      echo "getting access token from Dex: $DEX_URL"
      response_header_file='${{ runner.temp }}/dex-response-headers.txt'

      debug_dex() {
        debug "DEX_TOKEN_RESPONSE (RAW)" "${DEX_TOKEN_RESPONSE}"c
        debug "dex response headers" $(cat "${response_header_file}")
        debug "port-forward-log" $(cat '${{ inputs.port-forward-log }}')
      
        if [ '${{ inputs.mise-install }}' == "true" ]; then
          debug "stern logs" $(stern argocd-server --no-follow)
        fi
      }
      
      if DEX_TOKEN_RESPONSE=$(curl -v -sS --fail-with-body --dump-header "${response_header_file}" \
          ${{ inputs.dex-curl-options }} \
          "$DEX_URL" \
          --user "argo-cd-cli:" \
          --data-urlencode "connector_id=github-actions" \
          --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
          --data-urlencode "scope=openid email profile federated:id" \
          --data-urlencode "requested_token_type=urn:ietf:params:oauth:token-type:access_token" \
          --data-urlencode "subject_token=$GH_TOKEN" \
          --data-urlencode "subject_token_type=urn:ietf:params:oauth:token-type:id_token" \
      ); then
        echo "DEX_TOKEN_RESPONSE request success"
      else
        echo "DEX_TOKEN_RESPONSE request failed!"

        debug_dex

        exit 1
      fi

      debug_dex

      DEX_TOKEN=$(jq -r .access_token <<< $DEX_TOKEN_RESPONSE)

      if [[ -z "$DEX_TOKEN" ]]; then
        echo "::error::No token found in dex response"
        exit 1
      fi

      echo "::add-mask::$(echo "$DEX_TOKEN" | base64 -w0)"
      echo "::add-mask::$DEX_TOKEN"
      echo "dex-token=$DEX_TOKEN" >> "$GITHUB_OUTPUT"
      # use $DEX_TOKEN
  - name: argocd-upsert
    env:
      ARGOCD_AUTH_TOKEN: ${{ steps.idtoken.outputs.dex-token }}
    shell: bash
    run: |-
      argocd app create \
        --upsert \
        --file '${{ inputs.application-file }}' \
        --prompts-enabled=false \
        ;
  - name: argocd-sync
    env:
      ARGOCD_AUTH_TOKEN: ${{ steps.idtoken.outputs.dex-token }}
    shell: bash
    run: |-
      APPNAME=$(yq '.metadata.name' '${{ inputs.application-file }}')
      argocd app sync \
        "${APPNAME}" \
        --timeout ${{ inputs.timeout }} \
        ;
